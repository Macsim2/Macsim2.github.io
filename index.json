[{"content":"BOJ 2467 문제 같은 양의 두 용액을 혼합하여 특성값이 0 에 가장 가까운 용액을 만들려고 한다.\n입력 2 \u0026lt;= N \u0026lt;= 100,000\n예제 입력 1 5 -99 -2 -1 4 98\n예제 입력 2 4 -100 -2 -1 103\n출력 예제 출력 1 -99 98\n예제 출력 2 -2 -1 풀이 제한시간이 1초이고, 입력 범위가 $10^5$ 이므로 $n^2$ 의 시간복잡도를 넘어가면 안될 듯 하다. naive한 방식은 $n^2$ 인데 결국은 dp나 메모이제이션 등의 다른 풀이, 아이디어가 필요해 보인다. 그러다 투 포인터 방법으로 푸는게 직감적으로 맞겠다 싶었다. 문제는 투 포인터를 양끝에서 두고 시작하는것만 생각했는데, 검색 찬스로 시작부분에 l, r 두 포인터를 두고 푼다는 힌트를 듣고 풀었다.\n투포인터 방식은 두 포인터를 어떻게 움직이는 기준을 세우는지가 관건인것 같다. +) 용액이 정렬을 안해도 된다.\n","permalink":"http://localhost:1313/posts/tech/algorithm/boj/%EC%9A%A9%EC%95%A1/","summary":"BOJ 2467 문제 같은 양의 두 용액을 혼합하여 특성값이 0 에 가장 가까운 용액을 만들려고 한다. 입력 2 \u0026lt;= N \u0026lt;= 100,000 예제 입력 1 5 -99 -2 -1 4 98 예제 입력 2 4 -100 -2 -1 103 출력 예제 출력 1 -99 98 예제 출력 2 -2 -1 풀이 제한시간이 1초이고, 입력 범위가 $10^5$ 이므로 $n^2$ 의 시간복잡도를 넘어가면 안될 듯 하다. naive한 방식은 $n^2$ 인데 결국은 dp나 메모","title":"용액"},{"content":"BOJ 9252 문제 LCS(Longest Common Subsequence, 최장 공통 부분 수열)문제는 두 수열이 주어졌을 때, 모두의 부분 수열이 되는 수열 중 가장 긴 것을 찾는 문제이다. 예를 들어, ACAYKP와 CAPCAK의 LCS는 ACAK가 된다.\n입력 첫째 줄과 둘째 줄에 두 문자열이 주어진다. 문자열은 알파벳 대문자로만 이루어져 있으며, 최대 1000글자로 이루어져 있다.\n출력 첫째 줄에 입력으로 주어진 두 문자열의 LCS의 길이를, 둘째 줄에 LCS를 출력한다. LCS가 여러 가지인 경우에는 아무거나 출력하고, LCS의 길이가 0인 경우에는 둘째 줄을 출력하지 않는다.\n풀이 LCS과 다르게 LCS로 정해진 수열의 길이를 출력하는 것이 아닌 아무거나 하나를 구하는 조건이 더해졌다.\n문제를 보고 어떻게 할지 고민을 조금 했는데 더 간단한 풀이방법이 있어서 기록한다. LCS 문제는 2차원 배열을 만들고, 원소의 data type은 int형을 사용하여 LCS 길이를 구할 수 있었다. 그런데 LCS2는 2차원 배열을 사용하되, 원소의 data type를 string 을 사용해 LCS를 직접 구하는 방법을 사용할 수 있다.\n$$\\f\\relax{x} = \\int_{-\\infty}^\\infty \\f\\hat\\xi,e^{2 \\pi i \\xi x} ,d\\xi$$\n$$A=\\begin{bmatrix} 0 \u0026amp; 1 \u0026amp; 2 \\\\ 3 \u0026amp; 4 \u0026amp; 5 \\\\ 6 \u0026amp; 7 \u0026amp; 8 \\end{bmatrix} $$\n$$\\exp_a b = a^b$$ $\\sum\\nolimits_{k=1}^N k^2$\n$$\\begin{equation} f(x) = x^2+4x+16 \\end{equation}$$\n","permalink":"http://localhost:1313/posts/tech/algorithm/boj/lcs2/","summary":"BOJ 9252 문제 LCS(Longest Common Subsequence, 최장 공통 부분 수열)문제는 두 수열이 주어졌을 때, 모두의 부분 수열이 되는 수열 중 가장 긴 것을 찾는 문제이다. 예를 들어, ACAYKP와 CAPCAK의 LCS는 ACAK가 된다. 입력 첫째 줄과 둘째 줄에 두 문자열이 주어진다. 문자열은 알파벳 대문자로만 이루어져 있으며, 최대 1000글자로 이루어져 있다","title":"LCS2"},{"content":"","permalink":"http://localhost:1313/posts/life/test/","summary":"","title":"Test"},{"content":"1. 介绍 scan命令的作用和keys *的作用类似，主要用于查找redis中的键，但是在正式的生产环境中一般不会直接使用keys *这个命令，因为他会返回所有的键，如果键的数量很多会导致查询时间很长，进而导致服务器阻塞，所以需要scan来进行更细致的查找\nscan总共有这几种命令：scan、sscan、hscan、zscan，分别用于迭代数据库中的：数据库中所有键、集合键、哈希键、有序集合键，命令具体结构如下：\nscan cursor [MATCH pattern] [COUNT count] [TYPE type] sscan key cursor [MATCH pattern] [COUNT count] hscan key cursor [MATCH pattern] [COUNT count] zscan key cursor [MATCH pattern] [COUNT count] 2. scan scan cursor [MATCH pattern] [COUNT count] [TYPE type]，cursor表示游标，指查询开始的位置，count默认为10，查询完后会返回下一个开始的游标，当返回0的时候表示所有键查询完了\n127.0.0.1:6379[2]\u0026gt; scan 0 1) \u0026#34;3\u0026#34; 2) 1) \u0026#34;mystring\u0026#34; 2) \u0026#34;myzadd\u0026#34; 3) \u0026#34;myhset\u0026#34; 4) \u0026#34;mylist\u0026#34; 5) \u0026#34;myset2\u0026#34; 6) \u0026#34;myset1\u0026#34; 7) \u0026#34;mystring1\u0026#34; 8) \u0026#34;mystring3\u0026#34; 9) \u0026#34;mystring4\u0026#34; 10) \u0026#34;myset\u0026#34; 127.0.0.1:6379[2]\u0026gt; scan 3 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;myzadd1\u0026#34; 2) \u0026#34;mystring2\u0026#34; 3) \u0026#34;mylist2\u0026#34; 4) \u0026#34;myhset1\u0026#34; 5) \u0026#34;mylist1\u0026#34; MATCH可以采用模糊匹配找出自己想要查找的键，这里的逻辑是先查出20个，再匹配，而不是先匹配再查询，这里加上count 20是因为默认查出的10个数中可能不能包含所有的相关项，所以把范围扩大到查20个，我这里测试的键总共有15个\n127.0.0.1:6379[2]\u0026gt; scan 0 match mylist* count 20 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;mylist\u0026#34; 2) \u0026#34;mylist2\u0026#34; 3) \u0026#34;mylist1\u0026#34; TYPE可以根据具体的结构类型来匹配该类型的键\n127.0.0.1:6379[2]\u0026gt; scan 0 count 20 type list 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;mylist\u0026#34; 2) \u0026#34;mylist2\u0026#34; 3) \u0026#34;mylist1\u0026#34; 3. sscan sscan key cursor [MATCH pattern] [COUNT count]，sscan的第一个参数总是集合类型的key\n127.0.0.1:6379[2]\u0026gt; sadd myset1 a b c d (integer) 4 127.0.0.1:6379[2]\u0026gt; smembers myset1 1) \u0026#34;d\u0026#34; 2) \u0026#34;a\u0026#34; 3) \u0026#34;c\u0026#34; 4) \u0026#34;b\u0026#34; 127.0.0.1:6379[2]\u0026gt; sscan myset1 0 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;d\u0026#34; 2) \u0026#34;c\u0026#34; 3) \u0026#34;b\u0026#34; 4) \u0026#34;a\u0026#34; 127.0.0.1:6379[2]\u0026gt; sscan myset1 0 match a 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;a\u0026#34; 4. hscan hscan key cursor [MATCH pattern] [COUNT count]，sscan的第一个参数总是哈希类型的key\n127.0.0.1:6379[2]\u0026gt; hset myhset1 kk1 vv1 kk2 vv2 kk3 vv3 (integer) 3 127.0.0.1:6379[2]\u0026gt; hgetall myhset1 1) \u0026#34;kk1\u0026#34; 2) \u0026#34;vv1\u0026#34; 3) \u0026#34;kk2\u0026#34; 4) \u0026#34;vv2\u0026#34; 5) \u0026#34;kk3\u0026#34; 6) \u0026#34;vv3\u0026#34; 127.0.0.1:6379[2]\u0026gt; hscan myhset1 0 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;kk1\u0026#34; 2) \u0026#34;vv1\u0026#34; 3) \u0026#34;kk2\u0026#34; 4) \u0026#34;vv2\u0026#34; 5) \u0026#34;kk3\u0026#34; 6) \u0026#34;vv3\u0026#34; 5. zscan zscan key cursor [MATCH pattern] [COUNT count]，sscan的第一个参数总是有序集合类型的key\n127.0.0.1:6379[2]\u0026gt; zadd myzadd1 1 zz1 2 zz2 3 zz3 (integer) 3 127.0.0.1:6379[2]\u0026gt; zrange myzadd1 0 -1 withscores 1) \u0026#34;zz1\u0026#34; 2) \u0026#34;1\u0026#34; 3) \u0026#34;zz2\u0026#34; 4) \u0026#34;2\u0026#34; 5) \u0026#34;zz3\u0026#34; 6) \u0026#34;3\u0026#34; 127.0.0.1:6379[2]\u0026gt; zscan myzadd1 0 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;zz1\u0026#34; 2) \u0026#34;1\u0026#34; 3) \u0026#34;zz2\u0026#34; 4) \u0026#34;2\u0026#34; 5) \u0026#34;zz3\u0026#34; 6) \u0026#34;3\u0026#34; ","permalink":"http://localhost:1313/posts/tech/tmp/","summary":"1. 介绍 scan命令的作用和keys *的作用类似，主要用于查找redis中的键，但是在正式的生产环境中一般不会直接使用keys *这个命令，因为他会返回所有的键，如果键的数量很多会导致查询时间很长，进而导致服务器阻塞，所以需要scan来进行更细致的查找 scan总共有这几种命令：sca","title":"Redis scan命令学习"},{"content":"","permalink":"http://localhost:1313/posts/blog/blog/","summary":"","title":"Blog"},{"content":"","permalink":"http://localhost:1313/posts/life/life/","summary":"","title":"Life"},{"content":"","permalink":"http://localhost:1313/posts/read/read/","summary":"","title":"Read"},{"content":" Sulv\u0026#39;s Blog 一个记录技术、阅读、生活的博客 👉友链格式 名称： Sulv\u0026rsquo;s Blog 网址： https://www.sulvblog.cn 图标： https://www.sulvblog.cn/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求 秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内\n👉Hugo博客交流群 787018782\n","permalink":"http://localhost:1313/links/","summary":"Sulv\u0026#39;s Blog 一个记录技术、阅读、生活的博客 👉友链格式 名称： Sulv\u0026rsquo;s Blog 网址： https://www.sulvblog.cn 图标： https://www.sulvblog.cn/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求 秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内 👉Hugo博客交流群 787018782","title":"🤝友链"},{"content":"Signal and System FFT ASR Beamsearch Wav2vec 2.0 TLG HLG? DeepLearning linear regression SGD flash attention MachineLearning Algorithms BOJ LCS2 용액 ","permalink":"http://localhost:1313/archives/","summary":"Signal and System FFT ASR Beamsearch Wav2vec 2.0 TLG HLG? DeepLearning linear regression SGD flash attention MachineLearning Algorithms BOJ LCS2 용액","title":"archives"},{"content":"이 블로그는 저의 머릿속에 있는 추상적인 지식을 정리하고 기록하기 위해 만들어졌습니다. 특히 기술적인 포스트는 이미 알려져 있는 내용을 조합하거나 간단히 확인하는 것에 그칠 수 있습니다만, 저를 포함해 누군가에게는 도움이 되었으면 좋겠다는 바람은 가지고 글을 적습니다.\n혹시 제 글의 오류나 저작권 문제가 있는 경우, 댓글로 저에게 알려주시면 감사하겠습니다.\n","permalink":"http://localhost:1313/about/","summary":"이 블로그는 저의 머릿속에 있는 추상적인 지식을 정리하고 기록하기 위해 만들어졌습니다. 특히 기술적인 포스트는 이미 알려져 있는 내용을 조합하거나 간단히 확인하는 것에 그칠 수 있습니다만, 저를 포함해 누군가에게는 도움이 되었으면 좋겠다는 바람은 가지고 글을 적습니다. 혹시 제 글의 오류나 저작권 문제가 있는 경우, 댓글로 저에","title":"Introduction"}]