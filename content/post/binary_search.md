+++
author = "Macsim"
title = "Binary Search"
date = "2020-11-29"
description = "concepts of Search and feature of Binary Search."
tags = [
    "Search",
    "Binary Search"
]
categories = [
    "Algorithm"
]
+++
오늘은 Binary Search(이분 검색)에 대해서 알아보고자 한다.

이전에 검색에 대해 간단한 convention을 알아보자. <!--more-->

### **검색이란 무엇인가?**
> 자고로 검색이란 자료의 집합에서 특정한 키에 해당하는 자료를 찾는 일로써 매우 다양한 상황에서 발생한다.
또한 거의 모든 자료 관리 프로그램들은 다음과 같은 여섯 가지의 기능을 제공해야 한다. - <cite>ja ku lee[^1]</cite> 
[^1]: C로 배우는 알고리즘1  Jan 1, 2009 

1. 자료 파일 초기화
2. 자료 파일에서 특정한 키로 레코드 검색
3. 새로운 자료를 자료 파일에 삽입
4. 기존의 자료를 파일에서 삭제
5. 두 파일을 하나로 결합
6. 파일을 정렬

1-4까지의 기능은 자료 관리 프로그램에서는 보통 필수적으로 들어가 있는 듯 하다.

검색 알고리즘의 대부분은 자료를 특정한 방법으로 조직화한다. 이렇게 조직화되어 있는 자료 파일에서 임의로 하나의 자료를 삽입하거나 삭제하면 자칫 전체 자료 파일의 구조를 깨뜨리는 경우가 많다.
그래서 삽입과 삭제도 허용하는 검색 알고리즘의 경우에는 반드시 삽입 동작과 삭제 동작을 검색 동작과 함께 제공해야 한다.


## **Binary Search에 대해서**

이분 검색은 마치 퀵 정렬과 유사하게 <span style="color:yellow">분할해서 점령하라(Divide and conquer)</span>라는 전략을 사용한다.
이 전략을 사용하는 알고리즘은 문제의 크기를 거의 절반씩 나누어 가기 때문에 실행시간은 log의 성질을 가진다. 특히 정확히 양분하는 경우에는 최악의 경우라도 log<sub>2</sub>N의 성능을 가진다.

이분 검색은 순차 검색(sequencial search)에 비해서 자료의 정렬된 순서를 유지해야 하는 불리한 점이 있다.  이로 인해서 자료의 삽입과 삭제시에 평균 N/2개의 자료를 당기고 미는 부가적인 작업이 필요하다. 하지만 이 단점은 큰 자료에 대해 가지는 이분 검색의 장점을 생각한다면 충분히 납득할 수 있는 것이다.

**이분 검색은 삽입과 삭제의 어려움 때문에 삽입과 삭제가 적은 거의 고정적인 자료 집합에 매우 유용한 방법이다.** 또한 단순한 배열 구조를 그대로 사용하기 때문에 프로그래밍도 간단하고 구현도 쉽고 메모리의 낭비도 없다. 하지만 매우 동적인 자료 구조에 대해서는 단점이 있기 때문에 이분 검색 보다는 이진 나무 검색(Binary tree search)을 사용하는 것이 훨씬 좋다.

또한 개선 방법으로 <span style="color:yellow">**보간법**</span>을 사용할 수 있는데
만약 자료의 크기가 크고 매우 고른 분포를 가지고 있다면 보간법 중에서도 '선형 보간법'을 쉽게 적용할 수 있다.
로그에서 보간법은 로그의 그래프를 아주 잘게 쪼개었을 때는 직선으로 근사할 수 있으므로 비례의 법칙을 시용하여 로그의 근사값을 알 수 있다는 접근법이다.
(나중에 그림을 첨부하겠다.)

주의할 점은 근사치를 구하기 위해 곱셈과 나눗셈의 float형 연산이 생기기 때문에 분포가 고르지 못한 배열에서 사용했다가는 오히려 성능의 저하가 나타나게 된다. 하지만 적합한 경우에는 평균적으로 log<sub>2</sub>(log<sub>2</sub>N)정도의 평균 검색 시간이 걸리는것으로 알려져 있어 잘만 사용하면 좋은 개선법이 될 수 있다.

**보간법의 조건은 다시 말하지만 키값이 숫자화될 수 있으며 고르게 분포된 아주 큰 파일에 적합한 검색방법이다.**

